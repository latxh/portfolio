<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collab Hack v4</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }

        #canvas {
            display: block;
            background: white;
            cursor: crosshair;
            touch-action: none;
        }

        .connection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .connection-modal.hidden {
            display: none;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
            flex: 1;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
            margin-bottom: 10px;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 100;
        }

        .controls label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 500;
            color: #666;
        }

        .controls input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .controls input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        .controls button {
            width: 100%;
            margin-bottom: 8px;
            padding: 8px;
            font-size: 12px;
        }

        .peer-cursor {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4444;
            pointer-events: none;
            z-index: 50;
            transition: all 0.05s linear;
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 12px;
            z-index: 100;
        }

        .connection-status.connected {
            background: #4caf50;
            color: white;
        }

        .connection-status.disconnected {
            background: #f44336;
            color: white;
        }

        .step {
            display: none;
        }

        .step.active {
            display: block;
        }

        .copy-btn {
            background: #28a745;
            margin-top: 5px;
        }

        .copy-btn:hover {
            background: #218838;
        }

        .debug-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 10px;
            border-radius: 8px;
            max-width: 400px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .debug-panel.visible {
            display: block;
        }

        .debug-panel div {
            margin: 2px 0;
        }

        .debug-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            z-index: 100;
        }

        .debug-toggle:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <label>Color</label>
        <input type="color" id="colorPicker" value="#000000">
        
        <label>Brush Size: <span id="sizeValue">5</span>px</label>
        <input type="range" id="brushSize" min="1" max="50" value="5">
        
        <button id="undoBtn">Undo</button>
        <button id="clearBtn">Clear All</button>
        <button id="reconnectBtn" style="background: #ff9800;">Reconnect</button>
    </div>

    <div class="connection-status disconnected" id="connectionStatus">Disconnected</div>

    <div class="debug-toggle" id="debugToggle">Debug Info</div>
    <div class="debug-panel" id="debugPanel"></div>

    <div class="connection-modal" id="connectionModal">
        <div class="modal-content">
            <h2>P2P Whiteboard Connection</h2>
            
            <div id="step1" class="step active">
                <p style="margin-bottom: 15px;">Choose how to connect:</p>
                <div class="btn-group">
                    <button id="createBtn">Create Room</button>
                    <button id="joinBtn">Join Room</button>
                </div>
            </div>

            <div id="step2" class="step">
                <p style="margin-bottom: 10px;">Copy this connection string and send it to your peer:</p>
                <textarea id="offerText" readonly></textarea>
                <button class="copy-btn" id="copyOfferBtn">Copy to Clipboard</button>
                <div class="status info">Waiting for peer's response...</div>
                
                <p style="margin: 20px 0 10px;">Paste the response from your peer here:</p>
                <textarea id="answerInput" placeholder="Paste answer here..."></textarea>
                <button id="submitAnswerBtn">Submit Answer</button>
            </div>

            <div id="step3" class="step">
                <p style="margin-bottom: 10px;">Paste the connection string from your peer:</p>
                <textarea id="offerInput" placeholder="Paste offer here..."></textarea>
                <button id="submitOfferBtn">Connect</button>
            </div>

            <div id="step4" class="step">
                <p style="margin-bottom: 10px;">Copy this response and send it back to your peer:</p>
                <textarea id="answerText" readonly></textarea>
                <button class="copy-btn" id="copyAnswerBtn">Copy to Clipboard</button>
                <div class="status success">Connecting...</div>
            </div>

            <div id="statusDiv"></div>
        </div>
    </div>

    <script>
        // Utility classes
        class Vec2 {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
        }

        class Color {
            constructor(r, g, b) {
                this.r = r;
                this.g = g;
                this.b = b;
            }

            toColorString() {
                return `rgb(${this.r},${this.g},${this.b})`;
            }
        }

        // Stroke class for drawing
        class Stroke {
            constructor(color, width) {
                this.points = [];
                this.color = color;
                this.width = width;
            }

            addPoint(x, y) {
                this.points.push(new Vec2(x, y));
            }

            draw(ctx) {
                if (this.points.length < 2) return;
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.stroke();
            }

            serialize() {
                return {
                    points: this.points,
                    color: this.color,
                    width: this.width
                };
            }

            static deserialize(data) {
                const stroke = new Stroke(data.color, data.width);
                stroke.points = data.points.map(p => new Vec2(p.x, p.y));
                return stroke;
            }
        }

        // P2P Connection Manager
        class P2PManager {
            constructor() {
                this.pc = null;
                this.dataChannel = null;
                this.isHost = false;
                this.connected = false;
                this.onMessage = null;
                this.onConnectionChange = null;
                
                this.iceServers = [
                    // Multiple STUN servers for redundancy
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    // Free TURN servers from Open Relay (metered.ca)
                    {
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    {
                        urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    },
                    // Alternative free TURN server (Twilio)
                    {
                        urls: 'turn:global.turn.twilio.com:3478?transport=udp',
                        username: 'f4b4035eaa76f4a55de5f4351567653ee4ff6fa97b50b6b334fcc1be9c27212d',
                        credential: '2zlWWqRrzN0Ys9eKYOjKTIg+BXCJJ9TsFbJEBQhFwAg='
                    },
                    {
                        urls: 'turn:global.turn.twilio.com:3478?transport=tcp',
                        username: 'f4b4035eaa76f4a55de5f4351567653ee4ff6fa97b50b6b334fcc1be9c27212d',
                        credential: '2zlWWqRrzN0Ys9eKYOjKTIg+BXCJJ9TsFbJEBQhFwAg='
                    },
                    {
                        urls: 'turn:global.turn.twilio.com:443?transport=tcp',
                        username: 'f4b4035eaa76f4a55de5f4351567653ee4ff6fa97b50b6b334fcc1be9c27212d',
                        credential: '2zlWWqRrzN0Ys9eKYOjKTIg+BXCJJ9TsFbJEBQhFwAg='
                    }
                ];
            }

            async createOffer() {
                this.isHost = true;
                this.log('Creating offer with ' + this.iceServers.length + ' ICE servers');
                this.pc = new RTCPeerConnection({ 
                    iceServers: this.iceServers,
                    iceCandidatePoolSize: 10
                });
                this.setupConnectionMonitoring();
                
                this.dataChannel = this.pc.createDataChannel('whiteboard');
                this.setupDataChannel();
                
                const offer = await this.pc.createOffer();
                await this.pc.setLocalDescription(offer);
                
                this.log('ðŸ“¡ Gathering ICE candidates...');
                
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        this.log('â±ï¸ ICE gathering timeout, using what we have');
                        resolve(JSON.stringify(this.pc.localDescription));
                    }, 10000); // 10 second timeout
                    
                    const checkState = () => {
                        if (this.pc.iceGatheringState === 'complete') {
                            clearTimeout(timeout);
                            this.log('âœ”ï¸ ICE gathering complete');
                            resolve(JSON.stringify(this.pc.localDescription));
                        } else {
                            setTimeout(checkState, 100);
                        }
                    };
                    checkState();
                });
            }

            log(message) {
                if (this.debug && this.debug.log) {
                    this.debug.log(message);
                } else {
                    console.log(message);
                }
            }

            async handleAnswer(answerJson) {
                try {
                    this.log('ðŸ“¥ Handling answer from peer');
                    const answer = JSON.parse(answerJson);
                    await this.pc.setRemoteDescription(new RTCSessionDescription(answer));
                    this.log('âœ… Remote description (answer) set successfully');
                } catch (error) {
                    this.log('âŒ Error handling answer: ' + error.message);
                    throw error;
                }
            }

            async createAnswer(offerJson) {
                this.isHost = false;
                this.log('Creating answer with ' + this.iceServers.length + ' ICE servers');
                this.pc = new RTCPeerConnection({ 
                    iceServers: this.iceServers,
                    iceCandidatePoolSize: 10
                });
                this.setupConnectionMonitoring();
                
                this.pc.ondatachannel = (event) => {
                    this.dataChannel = event.channel;
                    this.setupDataChannel();
                };
                
                const offer = JSON.parse(offerJson);
                this.log('ðŸ“¥ Setting remote description (offer)');
                await this.pc.setRemoteDescription(new RTCSessionDescription(offer));
                
                const answer = await this.pc.createAnswer();
                await this.pc.setLocalDescription(answer);
                
                this.log('ðŸ“¡ Gathering ICE candidates for answer...');
                
                return new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        this.log('â±ï¸ ICE gathering timeout, using what we have');
                        resolve(JSON.stringify(this.pc.localDescription));
                    }, 10000); // 10 second timeout
                    
                    const checkState = () => {
                        if (this.pc.iceGatheringState === 'complete') {
                            clearTimeout(timeout);
                            this.log('âœ”ï¸ ICE gathering complete');
                            resolve(JSON.stringify(this.pc.localDescription));
                        } else {
                            setTimeout(checkState, 100);
                        }
                    };
                    checkState();
                });
            }

            setupConnectionMonitoring() {
                this.candidateCount = { host: 0, srflx: 0, relay: 0 };
                
                this.pc.oniceconnectionstatechange = () => {
                    this.log('ðŸ”— ICE state: ' + this.pc.iceConnectionState);
                    const status = document.getElementById('connectionStatus');
                    
                    switch (this.pc.iceConnectionState) {
                        case 'connected':
                        case 'completed':
                            status.textContent = 'Connected âœ“';
                            status.className = 'connection-status connected';
                            this.log('âœ… Connection established!');
                            break;
                        case 'disconnected':
                            status.textContent = 'Disconnected';
                            status.className = 'connection-status disconnected';
                            this.log('âš ï¸ Connection disconnected');
                            break;
                        case 'failed':
                            status.textContent = 'Connection Failed âœ—';
                            status.className = 'connection-status disconnected';
                            this.log('âŒ ICE connection failed');
                            break;
                        case 'checking':
                            status.textContent = 'Connecting...';
                            status.className = 'connection-status';
                            this.log('ðŸ”„ Checking connectivity...');
                            break;
                    }
                };

                this.pc.onicegatheringstatechange = () => {
                    this.log('ðŸ“¡ Gathering state: ' + this.pc.iceGatheringState);
                    if (this.pc.iceGatheringState === 'complete') {
                        const msg = `ðŸ“Š Candidates: host=${this.candidateCount.host} srflx=${this.candidateCount.srflx} relay=${this.candidateCount.relay}`;
                        this.log(msg);
                        
                        if (this.candidateCount.relay === 0) {
                            this.log('âš ï¸ No TURN candidates - may fail behind strict NATs');
                        }
                    }
                };

                this.pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const type = event.candidate.type;
                        const protocol = event.candidate.protocol;
                        this.candidateCount[type] = (this.candidateCount[type] || 0) + 1;
                        this.log(`ðŸŒ Candidate: ${type} (${protocol})`);
                    }
                };

                this.pc.onconnectionstatechange = () => {
                    this.log('ðŸ”Œ Connection state: ' + this.pc.connectionState);
                };
            }

            setupDataChannel() {
                this.dataChannel.onopen = () => {
                    this.connected = true;
                    if (this.onConnectionChange) this.onConnectionChange(true);
                };

                this.dataChannel.onclose = () => {
                    this.connected = false;
                    if (this.onConnectionChange) this.onConnectionChange(false);
                };

                this.dataChannel.onmessage = (event) => {
                    if (this.onMessage) {
                        const data = JSON.parse(event.data);
                        this.onMessage(data);
                    }
                };
            }

            send(data) {
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.dataChannel.send(JSON.stringify(data));
                }
            }

            close() {
                if (this.dataChannel) this.dataChannel.close();
                if (this.pc) this.pc.close();
                this.connected = false;
            }
        }

        // Debug Logger
        class DebugLogger {
            constructor() {
                this.panel = document.getElementById('debugPanel');
                this.toggle = document.getElementById('debugToggle');
                this.logs = [];
                this.maxLogs = 50;
                
                this.toggle.addEventListener('click', () => {
                    this.panel.classList.toggle('visible');
                });
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                this.logs.push(logEntry);
                
                if (this.logs.length > this.maxLogs) {
                    this.logs.shift();
                }
                
                this.panel.innerHTML = this.logs.map(log => `<div>${log}</div>`).join('');
                this.panel.scrollTop = this.panel.scrollHeight;
                
                // Also log to console
                console.log(message);
            }
        }

        // Whiteboard Application
        class Whiteboard {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.debug = new DebugLogger();
                this.p2p = new P2PManager();
                this.p2p.debug = this.debug; // Share debug logger
                this.strokes = [];
                this.currentStroke = null;
                this.isDrawing = false;
                this.peerCursor = null;
                
                this.debug.log('ðŸŽ¨ Whiteboard initialized');
                
                this.setupCanvas();
                this.setupControls();
                this.setupConnection();
                this.setupDrawing();
                
                window.addEventListener('resize', () => this.setupCanvas());
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.redraw();
            }

            setupControls() {
                document.getElementById('colorPicker').addEventListener('input', (e) => {
                    this.currentColor = e.target.value;
                });

                document.getElementById('brushSize').addEventListener('input', (e) => {
                    this.currentSize = parseInt(e.target.value);
                    document.getElementById('sizeValue').textContent = this.currentSize;
                });

                document.getElementById('undoBtn').addEventListener('click', () => {
                    this.undo();
                });

                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clear();
                });

                document.getElementById('reconnectBtn').addEventListener('click', () => {
                    document.getElementById('connectionModal').classList.remove('hidden');
                    this.showStep('step1');
                });

                this.currentColor = '#000000';
                this.currentSize = 5;
            }

            setupConnection() {
                const modal = document.getElementById('connectionModal');
                const statusDiv = document.getElementById('statusDiv');
                
                const showError = (message) => {
                    statusDiv.innerHTML = `<div class="status error">${message}</div>`;
                    console.error(message);
                };

                const showInfo = (message) => {
                    statusDiv.innerHTML = `<div class="status info">${message}</div>`;
                    console.log(message);
                };
                
                document.getElementById('createBtn').addEventListener('click', async () => {
                    try {
                        this.debug.log('ðŸš€ Starting as host...');
                        showInfo('Creating connection...');
                        const offer = await this.p2p.createOffer();
                        document.getElementById('offerText').value = offer;
                        this.showStep('step2');
                        statusDiv.innerHTML = '';
                    } catch (error) {
                        showError('Failed to create offer: ' + error.message);
                    }
                });

                document.getElementById('joinBtn').addEventListener('click', () => {
                    this.debug.log('ðŸ‘¥ Starting as peer...');
                    this.showStep('step3');
                });

                document.getElementById('copyOfferBtn').addEventListener('click', () => {
                    const text = document.getElementById('offerText').value;
                    navigator.clipboard.writeText(text);
                    alert('Copied to clipboard! Send this to your peer.');
                });

                document.getElementById('submitAnswerBtn').addEventListener('click', async () => {
                    const answer = document.getElementById('answerInput').value;
                    if (answer) {
                        try {
                            showInfo('Processing answer...');
                            await this.p2p.handleAnswer(answer);
                            showInfo('Answer processed. Connecting...');
                            // Don't close modal yet, wait for connection
                        } catch (error) {
                            showError('Failed to process answer: ' + error.message);
                        }
                    } else {
                        showError('Please paste the answer from your peer');
                    }
                });

                document.getElementById('submitOfferBtn').addEventListener('click', async () => {
                    const offer = document.getElementById('offerInput').value;
                    if (offer) {
                        try {
                            showInfo('Processing offer...');
                            const answer = await this.p2p.createAnswer(offer);
                            document.getElementById('answerText').value = answer;
                            this.showStep('step4');
                            statusDiv.innerHTML = '';
                        } catch (error) {
                            showError('Failed to create answer: ' + error.message);
                        }
                    } else {
                        showError('Please paste the offer from your peer');
                    }
                });

                document.getElementById('copyAnswerBtn').addEventListener('click', () => {
                    const text = document.getElementById('answerText').value;
                    navigator.clipboard.writeText(text);
                    alert('Copied to clipboard! Send this back to your peer.');
                });

                this.p2p.onConnectionChange = (connected) => {
                    const status = document.getElementById('connectionStatus');
                    if (connected) {
                        status.textContent = 'Connected';
                        status.className = 'connection-status connected';
                        modal.classList.add('hidden');
                        
                        // Send current state to peer
                        this.p2p.send({
                            type: 'sync',
                            strokes: this.strokes.map(s => s.serialize())
                        });
                    } else {
                        status.textContent = 'Disconnected';
                        status.className = 'connection-status disconnected';
                    }
                };

                this.p2p.onMessage = (data) => {
                    this.handlePeerMessage(data);
                };
            }

            showStep(stepId) {
                document.querySelectorAll('.step').forEach(step => {
                    step.classList.remove('active');
                });
                document.getElementById(stepId).classList.add('active');
            }

            setupDrawing() {
                const getPos = (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = (e.clientX || e.touches[0].clientX) - rect.left;
                    const y = (e.clientY || e.touches[0].clientY) - rect.top;
                    return { x, y };
                };

                this.canvas.addEventListener('pointerdown', (e) => {
                    this.isDrawing = true;
                    const pos = getPos(e);
                    this.startStroke(pos.x, pos.y);
                });

                this.canvas.addEventListener('pointermove', (e) => {
                    if (this.isDrawing) {
                        const pos = getPos(e);
                        this.addPoint(pos.x, pos.y);
                    }
                    
                    // Send cursor position to peer
                    if (this.p2p.connected) {
                        const pos = getPos(e);
                        this.p2p.send({
                            type: 'cursor',
                            x: pos.x,
                            y: pos.y
                        });
                    }
                });

                this.canvas.addEventListener('pointerup', (e) => {
                    if (this.isDrawing) {
                        this.isDrawing = false;
                        this.endStroke();
                    }
                });

                this.canvas.addEventListener('pointerout', (e) => {
                    if (this.isDrawing) {
                        this.isDrawing = false;
                        this.endStroke();
                    }
                });
            }

            startStroke(x, y) {
                this.currentStroke = new Stroke(this.currentColor, this.currentSize);
                this.currentStroke.addPoint(x, y);
                this.strokes.push(this.currentStroke);
                
                if (this.p2p.connected) {
                    this.p2p.send({
                        type: 'strokeStart',
                        x, y,
                        color: this.currentColor,
                        width: this.currentSize
                    });
                }
            }

            addPoint(x, y) {
                if (this.currentStroke) {
                    this.currentStroke.addPoint(x, y);
                    this.redraw();
                    
                    if (this.p2p.connected) {
                        this.p2p.send({
                            type: 'strokePoint',
                            x, y
                        });
                    }
                }
            }

            endStroke() {
                this.currentStroke = null;
                
                if (this.p2p.connected) {
                    this.p2p.send({
                        type: 'strokeEnd'
                    });
                }
            }

            undo() {
                if (this.strokes.length > 0) {
                    this.strokes.pop();
                    this.redraw();
                    
                    if (this.p2p.connected) {
                        this.p2p.send({ type: 'undo' });
                    }
                }
            }

            clear() {
                this.strokes = [];
                this.redraw();
                
                if (this.p2p.connected) {
                    this.p2p.send({ type: 'clear' });
                }
            }

            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.strokes.forEach(stroke => stroke.draw(this.ctx));
            }

            handlePeerMessage(data) {
                switch (data.type) {
                    case 'sync':
                        // Receive initial state from peer
                        this.strokes = data.strokes.map(s => Stroke.deserialize(s));
                        this.redraw();
                        break;
                        
                    case 'strokeStart':
                        this.currentStroke = new Stroke(data.color, data.width);
                        this.currentStroke.addPoint(data.x, data.y);
                        this.strokes.push(this.currentStroke);
                        break;
                        
                    case 'strokePoint':
                        if (this.currentStroke) {
                            this.currentStroke.addPoint(data.x, data.y);
                            this.redraw();
                        }
                        break;
                        
                    case 'strokeEnd':
                        this.currentStroke = null;
                        break;
                        
                    case 'undo':
                        if (this.strokes.length > 0) {
                            this.strokes.pop();
                            this.redraw();
                        }
                        break;
                        
                    case 'clear':
                        this.strokes = [];
                        this.redraw();
                        break;
                        
                    case 'cursor':
                        this.updatePeerCursor(data.x, data.y);
                        break;
                }
            }

            updatePeerCursor(x, y) {
                if (!this.peerCursor) {
                    this.peerCursor = document.createElement('div');
                    this.peerCursor.className = 'peer-cursor';
                    document.body.appendChild(this.peerCursor);
                }
                
                const rect = this.canvas.getBoundingClientRect();
                this.peerCursor.style.left = (rect.left + x) + 'px';
                this.peerCursor.style.top = (rect.top + y) + 'px';
            }
        }

        // Initialize the application
        const whiteboard = new Whiteboard();
    </script>
</body>
</html>

